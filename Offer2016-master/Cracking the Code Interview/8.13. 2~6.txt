^(*￣(oo)￣)^
关于C和C++的几个关键问题：
=======================================================================================
8.13.2 比较并对比散列表和STL map。散列表是如何实现的？如果输入的数据量不大，
可以选用哪些数据结构替代散列表？
答：
在散列表里，值的存放是通过将键传入散列函数实现的。值并不是以排序后的顺序存放。此外，
散列表以键找出索引，进而找到存放值的地方，因此，插入或查找操作均摊后可以在O(1)的时
间内完成（假定该散列表很少发生碰撞冲突）。散列表还必须处理潜在的碰撞冲突，一般通过
拉链法（chaining）解决，也即是创建一个链表来存放值，这些值的键都映射到同一个索引。

STL map的做法是根据键，将键值对插入二叉查找树。不需要处理冲突，因为树是平衡的，插入
和查找操作的时间肯定为O(logN)。

散列表是如何实现的？
传统上，散列表都是用元素为链表的数组实现的。想要插入键值对时，先用散列函数将键映射
为数组索引，随后，将值插入那个索引位置对应的链表。
注意，在数组的特定索引位置的链表中，各个元素的键并不相同，这些值的hashFunction(key)
才是相同的。因此，为了取回某个键对应的值，每个结点都必须存放键和值。
总而言之，散列表会以链表数组的形式实现，链表中每个结点都会存放两块数据：值和原先的
键。此外，我们还要注意以下设计准则、
（1）我们希望使用一个优良的散列函数，确保能将键均匀分散开来。若分散不均匀，就会发生
大量碰撞冲突，查找元素的速度也会变慢。
（2）不论散列函数选的多好，还是会出现碰撞冲突，因此需要一种碰撞处理方法。通常，我们
会选择拉链法，也就是通过链表来处理，但这并不是唯一的做法。
（3）我们可能还希望设法根据容量动态扩大或缩小散列表的大小。例如，当元素数量和散列表
大小之比超过一定阈值时，可能会希望扩大散列表的大小。这意味着要新建一个散列表，并将旧
的散列表条目转移到新的散列表中。因为这种操作的开销非常大，所以我们要谨慎些，不可频繁
操作。

如果输入的数据量不大，可以选用哪些数据结构代替散列表？
可以使用STL map或者二叉树。尽管两者的插入操作需要O(log(n))的时间，但若是输入数据量够
小，这点时间可以忽略不计。

==========================================================================================
8.13.3 C++虚函数的工作原理是什么？
答：
虚函数（virtual function）需要虚函数表（Vtable，Virtual Table）才能实现。如果一个类有
函数声明成虚拟的，就会生成一个Vtable，存放这个类的虚函数地址。此外，编译器还会在类里加
入隐藏的vptr变量。若子类没有覆写虚函数，该子类的Vtable就会存放父类的函数地址。调用这个
虚函数时，就会通过Vtable解析函数的地址。在C++里，动态绑定（dynamic binding）就是通过
Vtable机制实现的。
由此，将子类对象赋值给基类指针时，vptr变量就会指向子类的Vtable。这样一来，就能确保继承
关系最末端的子类虚函数会被调用到。

举例：
class Shape{
public:
	int edge_length;
	virtual int circumference(){
		cout<<"Circumference of Base Class.\n";
		return 0;
	}
};

class Triangle : public Shape{
public:
	int circumference(){
		cout<<"Circumference of Triangle Class.\n";
		return 3 * edge_length;
	}	
};

void main()
{
	Shape *x = new Shape();
	x->circumference();	//"Circumference of Base Class."
	Shape *y = new Triangle();
	y->circumference(); //"Circumference of Triangle Class."
}
在上面的代码中，circumference是Shape类的虚函数，因此在所有继承Shape类的子类（Triangle
类等）里都是虚函数。在C++里，非虚函数的调用是在编译期间通过静态绑定实现的，而虚函数的
调用则是在运行期间通过动态绑定实现的。

==========================================================================================
8.13.4 深拷贝和浅拷贝之间有何区别？请说明两者用法。
答：
浅拷贝会将对象所有成员的值拷贝到另一个对象里。除了拷贝所有成员的值，深拷贝还会进一步拷
贝所有指针对象。

举例：
struct Test{
	char *ptr;
};

void shallow_copy(Test &src , Test &dest)
{
	dest.ptr = src.ptr;
}

void deep_copy(Test &src , Test &dest)
{
	dest.ptr = (char *)malloc(strlen(src.ptr) + 1);
	strcpy(dest.ptr , src.ptr);
}

注意，shallow_copy可能会导致大量运行时错误，尤其是在对象创建和销毁时。使用浅拷贝时，
必须十分小心。在实际开发中，浅拷贝很少使用。大部分情况都应该使用深拷贝，特别是当需
要拷贝的结构很小时。

==========================================================================================
8.13.5 C语言的关键字“volatile”有何作用？
答：
关键字volatile的作用是指示编译器，即使代码不对变量做任何改动，该变量的值仍有可能会被
外界修改。操作系统、硬件或其他线程都有可能改变该变量。该变量的值有可能遭受意料之外的
修改。因此，每次使用时，编译器都会重新从内存中获取这个值。
volatile（易变）的整数可由下面的语句声明：
int volatile x;
volatile int x;
要声明指向volatile整数的指针：
volatile int *x;
int volatile *x;
指向非volatile数据的volatile指针少见，但也是可行的：
int *volatile x;
如若声明指向一块volatile内存的volatile指针变量（指针本身与地址所指内存都是volatile），
做法如下：
	
==========================================================================================
8.13.6 基类的析构函数为什么要声明为virtual？
答:
让我们先想想为何会有虚函数，假设有如下代码：
class Foo{
public:
	void f();
};

class Bar : public Foo{
public:
	void f();
};

Foo *p = new Bar();
p->f();
调用p->f()最后会调用Foo:f()，这是因为p是指向Foo的指针，而f()不是虚拟的。为确保p->f()会
调用继承关系最末端的子类的f()函数实现，我们需要将f()函数声明为虚函数。
现在，回到前面的析构函数。析构函数用于释放内存和资源。Foo的析构函数若不是虚拟的，那么即
使p实际上是Bar类型的，还是会调用Foo的析构函数。
这就是为何将析构函数声明为虚拟的原因 -- 确保正确调用继承关系最末端的子类的析构函数。



